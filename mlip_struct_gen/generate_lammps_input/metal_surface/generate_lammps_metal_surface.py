"""LAMMPS input file generator for metal surface simulations."""

import json
from dataclasses import dataclass
from pathlib import Path

from ...potentials import LJ_PARAMS_FILE
from ..base import BaseLAMMPSGenerator
from .input_parameters import MetalSurfaceLAMMPSParameters


@dataclass
class MetalSurfaceLAMMPSGenerator(BaseLAMMPSGenerator):
    """Generate LAMMPS input files for metal surface simulations."""

    parameters: MetalSurfaceLAMMPSParameters

    def __post_init__(self) -> None:
        """Initialize the metal surface generator."""
        # Load LJ parameters
        if LJ_PARAMS_FILE.exists():
            with open(LJ_PARAMS_FILE) as f:
                lj_data = json.load(f)
                self.lj_params = lj_data.get("metals", {})
        else:
            self.lj_params = {}

        # Initialize parent class
        super().__post_init__()

    def _generate_initialization_section(self) -> list[str]:
        """Generate LAMMPS initialization section for metal surface."""
        from datetime import datetime

        lines = []
        # Header comments
        lines.append(
            f"# LAMMPS input script for {self.parameters.metal_type} surface MD simulation"
        )
        lines.append(
            f"# Generated by mlip-struct-gen on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        )
        lines.append("# Potential type: LJ")
        lines.append(f"# Ensemble: {self.parameters.ensemble}")
        temp = (
            self.parameters.temperatures[0]
            if isinstance(self.parameters.temperatures, list)
            else self.parameters.temperatures
        )
        lines.append(f"# Temperature: {temp} K")
        if self.parameters.ensemble == "NPT":
            lines.append(f"# Pressure: {self.parameters.pressure} bar")
        lines.append(f"# Metal: {self.parameters.metal_type}")
        if self.parameters.fix_bottom_layers > 0:
            lines.append(f"# Fixed bottom layers: {self.parameters.fix_bottom_layers}")
        lines.append("")

        # Initialization
        lines.append("# Initialization")
        lines.append("clear")
        lines.append("units metal")  # Metal units for metal simulations
        lines.append("atom_style full")  # Full style to match data file format
        lines.append("boundary p p p")  # Periodic boundaries

        lines.append("")
        return lines

    def _generate_force_field_section(self, temperature: float) -> list[str]:
        """Generate metal force field section."""
        lines = []
        lines.append("# Force field parameters")
        lines.append(f"# {self.parameters.metal_type} Lennard-Jones potential")
        lines.append("")

        # Pair style
        lines.append(f"pair_style lj/cut {self.parameters.lj_cutoff}")

        # LJ parameters
        if self.parameters.metal_type in self.lj_params:
            lj = self.lj_params[self.parameters.metal_type]
            lines.append(f"# LJ parameters for {self.parameters.metal_type}")
            lines.append(f"# epsilon = {lj['epsilon']} eV, sigma = {lj['sigma']} Angstrom")
            lines.append(f"pair_coeff * * {lj['epsilon']} {lj['sigma']}")
        else:
            lines.append(f"# WARNING: No LJ parameters found for {self.parameters.metal_type}")
            lines.append("# Using default LJ parameters")
            lines.append("pair_coeff * * 0.5 2.5  # Default values - adjust as needed")

        lines.append("")

        # Neighbor list
        lines.append("# Neighbor list settings")
        lines.append("neighbor 2.0 bin")
        lines.append("neigh_modify every 1 delay 0 check yes")
        lines.append("")

        return lines

    def _generate_settings_section(self) -> list[str]:
        """Generate simulation settings for metal surface."""
        lines = []

        # Groups for surface layers
        lines.append("# Define groups for surface layers")
        if self.parameters.fix_bottom_layers > 0:
            lines.append("# Assuming atoms are ordered by z-coordinate")
            lines.append("# You may need to adjust these group definitions based on your structure")
            lines.append("")
            lines.append("# Sort atoms by z-coordinate to identify layers")
            lines.append("variable zcoord atom z")
            lines.append("run 0  # Update atom properties")
            lines.append("")

            # Create groups for fixed and mobile atoms
            lines.append("# Create groups (adjust the z-threshold based on your system)")
            lines.append("variable zmin equal bound(all,zmin)")
            lines.append(f"variable zfix equal ${{zmin}}+{self.parameters.fix_bottom_layers*3.0}")
            lines.append("region bottom_region block EDGE EDGE EDGE EDGE EDGE ${zfix}")
            lines.append("group bottom_atoms region bottom_region")
            lines.append("group mobile_atoms subtract all bottom_atoms")
            lines.append("")

            # Fix bottom layers
            lines.append("# Fix bottom layers")
            lines.append("fix freeze bottom_atoms setforce 0.0 0.0 0.0")
            lines.append("")
        else:
            # No fixed layers - all atoms are mobile
            lines.append("# All atoms are mobile")
            lines.append("# Create a region that includes entire simulation box")
            lines.append("region all_region block EDGE EDGE EDGE EDGE EDGE EDGE")
            lines.append("group mobile_atoms region all_region")
            lines.append("")

        # Compute properties for MLIP training
        if self.parameters.compute_stress:
            lines.append("# Compute per-atom stress for MLIP training")
            lines.append("compute stress_atom all stress/atom NULL")
            lines.append("")

        if self.parameters.compute_centro:
            lines.append("# Compute centrosymmetry parameter")
            lines.append("compute csym all centro/atom fcc")
            lines.append("")

        # Timestep (convert from fs to metal units if needed)
        lines.append("# Simulation setup")
        lines.append(
            f"timestep {self.parameters.timestep * 0.001}"
        )  # Convert fs to ps for metal units
        lines.append("")

        return lines

    def _generate_equilibration_section(self, temperature: float) -> list[str]:
        """Generate equilibration section for metal surface."""
        lines = []

        # Generate initial velocities
        lines.append("# Generate initial velocities")
        lines.append(
            f"velocity mobile_atoms create {temperature} {self.parameters.seed} dist gaussian"
        )
        lines.append("velocity mobile_atoms zero linear")
        lines.append("velocity mobile_atoms zero angular")
        lines.append("")

        # Output settings
        lines.append("# Output settings")
        lines.append("thermo 100")  # Every 100 steps during equilibration
        lines.append("thermo_style custom step temp pe ke etotal press vol")
        lines.append("")

        # Calculate equilibration steps (metal units: 1 timestep = 1 ps * timestep value)
        eq_steps = int(self.parameters.equilibration_time / (self.parameters.timestep * 0.001))

        lines.append("# Equilibration phase")
        lines.append(f"# {self.parameters.equilibration_time:.1f} ps ({eq_steps} steps)")
        lines.append("")

        # Equilibration trajectory dump
        eq_dump_steps = int(self.parameters.dump_frequency / (self.parameters.timestep * 0.001))
        lines.append("# Equilibration trajectory output")
        lines.append(
            f"dump eq_traj all custom {eq_dump_steps} eq_trajectory.lammpstrj id type element x y z"
        )
        lines.append("dump_modify eq_traj sort id")
        lines.append(f"dump_modify eq_traj element {self.parameters.metal_type}")
        lines.append("")

        # Equilibration ensemble
        if self.parameters.ensemble == "NPT":
            lines.append("# NPT ensemble with Nosé-Hoover thermostat and barostat")
            # Convert damping from fs to ps for metal units
            t_damp = self.parameters.thermostat_damping * 0.001
            p_damp = self.parameters.barostat_damping * 0.001
            # Convert pressure from bar to metal units (bar)
            lines.append(
                f"fix npt_eq mobile_atoms npt temp {temperature} {temperature} {t_damp} "
                f"iso {self.parameters.pressure} {self.parameters.pressure} {p_damp}"
            )
        elif self.parameters.ensemble == "NVT":
            lines.append("# NVT ensemble with Nosé-Hoover thermostat")
            t_damp = self.parameters.thermostat_damping * 0.001
            lines.append(f"fix nvt_eq mobile_atoms nvt temp {temperature} {temperature} {t_damp}")
        else:  # NVE
            lines.append("# NVE ensemble")
            lines.append("fix nve_eq mobile_atoms nve")

        lines.append("")
        lines.append("# Run equilibration")
        lines.append(f"run {eq_steps}")
        lines.append("")

        # Undump equilibration trajectory
        lines.append("undump eq_traj")
        lines.append("")

        # Unfix equilibration integrator
        lines.append("# Unfix equilibration integrator")
        if self.parameters.ensemble == "NPT":
            lines.append("unfix npt_eq")
        elif self.parameters.ensemble == "NVT":
            lines.append("unfix nvt_eq")
        else:
            lines.append("unfix nve_eq")

        lines.append("")
        return lines

    def _generate_production_section(self, temperature: float) -> list[str]:
        """Generate production section for metal surface with MLIP training output."""
        lines = []

        # Calculate production steps
        prod_steps = int(self.parameters.production_time / (self.parameters.timestep * 0.001))
        dump_steps = int(self.parameters.dump_frequency / (self.parameters.timestep * 0.001))

        lines.append("# Production phase")
        lines.append(f"# {self.parameters.production_time:.1f} ps ({prod_steps} steps)")
        lines.append("")

        lines.append("reset_timestep 0")
        lines.append("")

        # Production run output settings
        lines.append("# Production run output settings")
        lines.append(f"thermo {dump_steps}")
        lines.append("thermo_style custom step temp pe ke etotal press vol")
        lines.append("")

        # Trajectory output for MLIP training
        lines.append("# Trajectory output for MLIP training")

        # File naming based on temperature
        temps = (
            self.parameters.temperatures
            if isinstance(self.parameters.temperatures, list)
            else [self.parameters.temperatures]
        )
        data_stem = Path(self.parameters.data_file).stem
        if len(temps) > 1:
            traj_file = f"{data_stem}_T{temperature:.0f}.lammpstrj"
        else:
            traj_file = "trajectory.lammpstrj"

        # Dump with forces and optionally stress
        dump_vars = "id type element x y z fx fy fz"
        if self.parameters.compute_stress:
            dump_vars += " c_stress_atom[1] c_stress_atom[2] c_stress_atom[3] c_stress_atom[4] c_stress_atom[5] c_stress_atom[6]"
        if self.parameters.compute_centro:
            dump_vars += " c_csym"

        lines.append(f"dump trajectory all custom {dump_steps} {traj_file} {dump_vars}")
        lines.append("dump_modify trajectory sort id")
        # Add element mapping so trajectory file has proper element information
        lines.append(f"dump_modify trajectory element {self.parameters.metal_type}")
        lines.append("")

        # Production ensemble
        if self.parameters.ensemble == "NPT":
            lines.append("# NPT ensemble with Nosé-Hoover thermostat and barostat")
            t_damp = self.parameters.thermostat_damping * 0.001
            p_damp = self.parameters.barostat_damping * 0.001
            lines.append(
                f"fix npt_prod mobile_atoms npt temp {temperature} {temperature} {t_damp} "
                f"iso {self.parameters.pressure} {self.parameters.pressure} {p_damp}"
            )
        elif self.parameters.ensemble == "NVT":
            lines.append("# NVT ensemble with Nosé-Hoover thermostat")
            t_damp = self.parameters.thermostat_damping * 0.001
            lines.append(f"fix nvt_prod mobile_atoms nvt temp {temperature} {temperature} {t_damp}")
        else:  # NVE
            lines.append("# NVE ensemble")
            lines.append("fix nve_prod mobile_atoms nve")

        lines.append("")
        lines.append("# Run production")
        lines.append(f"run {prod_steps}")
        lines.append("")

        # Final output
        lines.append("# Final output")
        lines.append("write_data final.data")
        lines.append("")

        # Unfix production integrator
        if self.parameters.ensemble == "NPT":
            lines.append("unfix npt_prod")
        elif self.parameters.ensemble == "NVT":
            lines.append("unfix nvt_prod")
        else:
            lines.append("unfix nve_prod")

        if self.parameters.fix_bottom_layers > 0:
            lines.append("unfix freeze")

        lines.append("undump trajectory")
        lines.append("")

        return lines
