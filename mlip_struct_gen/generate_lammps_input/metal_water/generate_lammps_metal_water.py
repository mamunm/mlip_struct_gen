"""LAMMPS input file generator for metal-water interface simulations."""

import json
from dataclasses import dataclass

from ...potentials import LJ_PARAMS_FILE
from ..base import BaseLAMMPSGenerator
from .input_parameters import MetalWaterLAMMPSParameters

# Water model parameters for metal units (eV, Angstrom, ps)
WATER_MODELS_METAL = {
    "SPC/E": {
        "O_mass": 15.9994,
        "H_mass": 1.008,
        "O_charge": -0.8476,
        "H_charge": 0.4238,
        "O_epsilon": 0.006808,  # 0.1553 kcal/mol = 0.006808 eV
        "O_sigma": 3.16556,  # Angstrom
        "H_epsilon": 0.0,
        "H_sigma": 0.0,
        "bond_k": 95.83,  # eV/Ang^2 (converted from SPC/E)
        "bond_r0": 1.0,  # Angstrom
        "angle_k": 10.42,  # eV/rad^2 (converted from SPC/E)
        "angle_theta0": 109.47,  # degrees
    },
    "TIP3P": {
        "O_mass": 15.9994,
        "H_mass": 1.008,
        "O_charge": -0.834,
        "H_charge": 0.417,
        "O_epsilon": 0.006661,  # 0.1521 kcal/mol = 0.006661 eV
        "O_sigma": 3.1507,  # Angstrom
        "H_epsilon": 0.0,
        "H_sigma": 0.0,
        "bond_k": 95.83,  # eV/Ang^2
        "bond_r0": 0.9572,  # Angstrom
        "angle_k": 12.0,  # eV/rad^2
        "angle_theta0": 104.52,  # degrees
    },
}


@dataclass
class MetalWaterLAMMPSGenerator(BaseLAMMPSGenerator):
    """Generate LAMMPS input files for metal-water interface simulations."""

    parameters: MetalWaterLAMMPSParameters

    def __post_init__(self) -> None:
        """Initialize the metal-water generator."""
        # Load LJ parameters for metals
        if LJ_PARAMS_FILE.exists():
            with open(LJ_PARAMS_FILE) as f:
                lj_data = json.load(f)
                self.metal_lj_params = lj_data.get("metals", {})
        else:
            self.metal_lj_params = {}

        # Get water model parameters for metal units
        self.water_params = WATER_MODELS_METAL.get(
            self.parameters.water_model, WATER_MODELS_METAL["SPC/E"]
        )

        # Get atomic masses
        self.metal_masses = {
            "Cu": 63.546,
            "Ag": 107.8682,
            "Au": 196.9666,
            "Ni": 58.6934,
            "Pd": 106.42,
            "Pt": 195.078,
            "Al": 26.9815,
        }

        # Initialize parent class
        super().__post_init__()

    def _generate_initialization_section(self) -> list[str]:
        """Generate LAMMPS initialization section for metal-water interface."""
        from datetime import datetime

        lines = []
        # Header comments
        lines.append(
            f"# LAMMPS Input File: {self.parameters.metal_type}-Water {self.parameters.ensemble} at {self.parameters.temperatures[0] if isinstance(self.parameters.temperatures, list) else self.parameters.temperatures}K"
        )
        lines.append(
            f"# Generated by mlip-struct-gen on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        )
        lines.append(f"# Atom types: 1={self.parameters.metal_type}, 2=O, 3=H")
        lines.append(f"# Water model: {self.parameters.water_model}")
        if self.parameters.metal_type in self.metal_lj_params:
            lj = self.metal_lj_params[self.parameters.metal_type]
            lines.append(
                f"# LJ potential: sigma={lj['sigma']:.3f} A, epsilon={lj['epsilon']:.6f} eV"
            )
        lines.append("")

        # Initialization
        lines.append("# Initialization")
        lines.append("units metal")  # metal units (eV, Angstrom, ps)
        lines.append("dimension 3")
        lines.append("boundary p p p")  # Periodic boundaries
        lines.append("atom_style full")  # Full style for molecular systems
        lines.append("")

        return lines

    def _generate_force_field_section(self, temperature: float) -> list[str]:
        """Generate metal-water force field section."""
        lines = []

        # Set masses
        lines.append("# Set masses (required for metal units)")
        metal_mass = self.metal_masses.get(self.parameters.metal_type, 100.0)
        lines.append(f"mass 1 {metal_mass:.3f}  # {self.parameters.metal_type} atomic mass")
        lines.append(f"mass 2 {self.water_params['O_mass']:.4f}  # O atomic mass")
        lines.append(f"mass 3 {self.water_params['H_mass']:.3f}  # H atomic mass")
        lines.append("")

        # Define potentials
        lines.append(f"# Define potentials for {self.parameters.metal_type}-water system")
        lines.append(
            f"# {self.parameters.water_model} water parameters for metal units (eV, Angstrom)"
        )
        lines.append("pair_style lj/cut/coul/long 10.0 10.0")
        lines.append("")

        # Metal-metal interactions
        if self.parameters.metal_type in self.metal_lj_params:
            metal_lj = self.metal_lj_params[self.parameters.metal_type]
            lines.append(
                f"# {self.parameters.metal_type}-{self.parameters.metal_type} interactions (LJ potential)"
            )
            lines.append(
                f"pair_coeff 1 1 {metal_lj['epsilon']:.6f} {metal_lj['sigma']:.3f}   "
                f"# epsilon={metal_lj['epsilon']:.6f} eV, sigma={metal_lj['sigma']:.3f} A"
            )
        else:
            lines.append(f"# WARNING: No LJ parameters found for {self.parameters.metal_type}")
            lines.append("# Using default metal LJ parameters")
            lines.append("pair_coeff 1 1 0.5 2.5  # Default values")
        lines.append("")

        # Water-water interactions
        lines.append(
            f"# {self.parameters.water_model} water interactions (converted to metal units)"
        )
        lines.append("# O-O interactions")
        lines.append(
            f"pair_coeff 2 2 {self.water_params['O_epsilon']:.6f} {self.water_params['O_sigma']:.5f}   "
            f"# epsilon={self.water_params['O_epsilon']:.6f} eV"
        )
        lines.append("")

        lines.append("# H-H interactions (typically zero)")
        lines.append("pair_coeff 3 3 0.0000 0.0000")
        lines.append("")

        lines.append("# O-H interactions (zero LJ, only Coulomb)")
        lines.append("pair_coeff 2 3 0.0000 0.0000")
        lines.append("")

        # Metal-water interactions (geometric mixing rule)
        lines.append("# Metal-water interactions (geometric mixing rule)")
        if self.parameters.metal_type in self.metal_lj_params:
            metal_lj = self.metal_lj_params[self.parameters.metal_type]

            # Metal-O interaction
            mo_epsilon = (metal_lj["epsilon"] * self.water_params["O_epsilon"]) ** 0.5
            mo_sigma = (metal_lj["sigma"] + self.water_params["O_sigma"]) / 2
            lines.append(f"# {self.parameters.metal_type}-O interaction")
            lines.append(
                f"# epsilon_{self.parameters.metal_type}-O = sqrt(epsilon_{self.parameters.metal_type} * epsilon_O) = {mo_epsilon:.4f}"
            )
            lines.append(
                f"# sigma_{self.parameters.metal_type}-O = (sigma_{self.parameters.metal_type} + sigma_O) / 2 = {mo_sigma:.3f}"
            )
            lines.append(f"pair_coeff 1 2 {mo_epsilon:.4f} {mo_sigma:.3f}")
            lines.append("")

            # Metal-H interaction (weak)
            lines.append(f"# {self.parameters.metal_type}-H interaction (weak)")
            mh_sigma = metal_lj["sigma"] / 2  # Much smaller for H
            lines.append(
                f"pair_coeff 1 3 0.0100 {mh_sigma:.3f}    # {self.parameters.metal_type}-H: weak interaction"
            )
        else:
            lines.append("# Using default metal-water interactions")
            lines.append("pair_coeff 1 2 0.05 3.0")
            lines.append("pair_coeff 1 3 0.01 1.5")
        lines.append("")

        # Bond potential for water
        lines.append(f"# Bond potential for {self.parameters.water_model} water (O-H bonds)")
        lines.append("bond_style harmonic")
        lines.append(
            f"bond_coeff 1 {self.water_params['bond_k']:.2f} {self.water_params['bond_r0']:.1f}           "
            f"# k={self.water_params['bond_k']:.2f} eV/Ang^2, r0={self.water_params['bond_r0']:.1f} Ang"
        )
        lines.append("")

        # Angle potential for water
        lines.append(f"# Angle potential for {self.parameters.water_model} water (H-O-H angle)")
        lines.append("angle_style harmonic")
        lines.append(
            f"angle_coeff 1 {self.water_params['angle_k']:.2f} {self.water_params['angle_theta0']:.2f}       "
            f"# k={self.water_params['angle_k']:.2f} eV/rad^2, theta0={self.water_params['angle_theta0']:.2f} deg"
        )
        lines.append("")

        # Long-range Coulombics
        lines.append("# Long-range Coulombics")
        lines.append(f"kspace_style pppm {self.parameters.coulomb_accuracy}")
        lines.append("")

        lines.append(
            f"# Charges are already defined in data file for {self.parameters.water_model} water"
        )
        lines.append(
            f"# O: {self.water_params['O_charge']:.4f} e, H: {self.water_params['H_charge']:.4f} e"
        )
        lines.append("")

        # Neighbor settings
        lines.append("# Neighbor settings")
        lines.append("neighbor 2.0 bin")
        lines.append("neigh_modify every 1 delay 0 check yes")
        lines.append("")

        return lines

    def _generate_settings_section(self) -> list[str]:
        """Generate simulation settings for metal-water interface."""
        lines = []

        # Define groups for temperature computation
        lines.append("# Define groups for temperature computation")
        lines.append("group water type 2 3  # O and H atoms")
        lines.append("group metal type 1")
        lines.append("")

        # Compute water temperature
        lines.append("# Compute water temperature")
        lines.append("compute temp_water water temp")
        lines.append("")

        # Time integration and thermostat settings will be in equilibration/production
        # Timestep (convert fs to ps for metal units)
        self.parameters.timestep * 0.001  # Convert fs to ps

        # SHAKE constraints for rigid water molecules
        lines.append("# SHAKE constraints for rigid water molecules")
        lines.append(
            "fix shake all shake 0.0001 20 0 b 1 a 1          # constrain O-H bonds and H-O-H angles"
        )
        lines.append("")

        # Compute properties for MLIP training if needed
        if self.parameters.compute_stress:
            lines.append("# Compute per-atom stress for MLIP training")
            lines.append("compute stress_atom all stress/atom NULL")
            lines.append("")

        return lines

    def _generate_equilibration_section(self, temperature: float) -> list[str]:
        """Generate equilibration section for metal-water interface."""
        lines = []

        # Timestep
        timestep_ps = self.parameters.timestep * 0.001  # Convert fs to ps
        lines.append("# Time integration setup")
        lines.append(
            f"timestep {timestep_ps:.3f}                                     # {self.parameters.timestep:.1f} fs timestep"
        )
        lines.append("")

        # Ensemble setup with fix bottom layers if needed
        if self.parameters.fix_bottom_layers > 0:
            lines.append("# Define groups for fixed layers")
            lines.append("group metal type 1")
            lines.append("variable zmin equal bound(metal,zmin)")
            lines.append(f"variable zfix equal ${{zmin}}+{self.parameters.fix_bottom_layers*3.0}")
            lines.append("region bottom_region block EDGE EDGE EDGE EDGE EDGE ${zfix}")
            lines.append("group bottom_metal region bottom_region")
            lines.append("group mobile_atoms subtract all bottom_metal")
            lines.append("fix freeze bottom_metal setforce 0.0 0.0 0.0")
            lines.append("")
            fix_group = "mobile_atoms"
        else:
            fix_group = "all"

        # Thermostat and barostat
        damping_ps = self.parameters.thermostat_damping * 0.001  # Convert fs to ps

        if self.parameters.ensemble == "NVT":
            lines.append("# Time integration and thermostat")
            lines.append(
                f"fix nvt {fix_group} nvt temp {temperature:.1f} {temperature:.1f} {damping_ps:.1f}              "
                f"# {damping_ps:.1f} ps damping time"
            )
        elif self.parameters.ensemble == "NPT":
            barostat_damping_ps = self.parameters.barostat_damping * 0.001
            # Convert pressure from bar to metal units (bar)
            lines.append("# Time integration with NPT ensemble")
            lines.append(
                f"fix npt {fix_group} npt temp {temperature:.1f} {temperature:.1f} {damping_ps:.1f} "
                f"iso {self.parameters.pressure:.1f} {self.parameters.pressure:.1f} {barostat_damping_ps:.1f}"
            )
        else:  # NVE
            lines.append("# Time integration with NVE ensemble")
            lines.append(f"fix nve {fix_group} nve")
        lines.append("")

        # Output settings
        lines.append("# Output settings")
        lines.append(
            "thermo_style custom step time temp c_temp_water pe ke etotal press vol density"
        )
        lines.append('thermo_modify colname c_temp_water "T_water"')
        eq_steps = int(self.parameters.equilibration_time / timestep_ps)
        thermo_out = min(1000, eq_steps // 100)  # Output ~100 times during equilibration
        lines.append(
            f"thermo {thermo_out}                                        # output every {thermo_out} steps"
        )
        lines.append("")

        # Run equilibration
        lines.append("# Equilibration phase")
        lines.append(f"# {self.parameters.equilibration_time:.1f} ps = {eq_steps} steps")
        lines.append(f"run {eq_steps}")
        lines.append("")

        return lines

    def _generate_production_section(self, temperature: float) -> list[str]:
        """Generate production section for metal-water interface with MLIP training output."""
        lines = []

        # Reset timestep for production
        lines.append("# Reset for production run")
        lines.append("reset_timestep 0")
        lines.append("")

        # Calculate production steps
        timestep_ps = self.parameters.timestep * 0.001  # Convert fs to ps
        prod_steps = int(self.parameters.production_time / timestep_ps)
        dump_steps = int(self.parameters.dump_frequency / timestep_ps)
        restart_steps = min(50000, prod_steps // 10)  # Restart files every 10% of run
        thermo_steps = int(self.parameters.dump_frequency / timestep_ps)  # Same as dump frequency

        # Production thermo output settings
        lines.append("# Production thermo output")
        lines.append(f"thermo {thermo_steps}")
        lines.append(
            "thermo_style custom step time temp c_temp_water pe ke etotal press vol density"
        )
        lines.append('thermo_modify colname c_temp_water "T_water"')
        lines.append("")

        # Trajectory output
        lines.append("# Trajectory output with custom format")
        traj_file = "trajectory.lammpstrj"

        # Basic dump with positions
        lines.append(f"dump traj all custom {dump_steps} {traj_file} id type x y z")
        lines.append("")

        # Force dump if needed for MLIP
        if self.parameters.compute_stress:
            lines.append("# Force and stress output for MLIP training")
            lines.append(
                f"dump forces all custom {dump_steps} forces.dump id type x y z fx fy fz c_stress_atom[*]"
            )
            lines.append("")

        # Restart files
        lines.append("# Restart files")
        lines.append(
            f"restart {restart_steps} restart1.lmp restart2.lmp           # restart files every {restart_steps} steps"
        )
        lines.append("")

        # Run production
        lines.append("# Run simulation")
        lines.append(f"# {self.parameters.production_time:.1f} ps = {prod_steps} steps")
        lines.append(f"run {prod_steps}")
        lines.append("")

        # Write final configuration
        lines.append("# Write final configuration")
        lines.append("write_data final_configuration.data")
        lines.append("")

        lines.append(
            f'print "Simulation completed: {self.parameters.production_time:.1f} ps {self.parameters.ensemble} at {temperature:.1f}K"'
        )
        lines.append("")

        return lines
