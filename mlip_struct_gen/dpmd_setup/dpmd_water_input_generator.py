"""LAMMPS input file generator for DPMD-based water simulations."""

from pathlib import Path
from typing import Union
import datetime

from .dpmd_input_parameters import DPMDInputParameters, DPMDWaterInputParameters


class DPMDWaterInputGenerator:
    """Generate LAMMPS input files for water MD simulations using DeepMD potentials."""
    
    def __init__(self, parameters: DPMDInputParameters):
        """
        Initialize DPMD water input generator.
        
        Args:
            parameters: DPMD simulation parameters
            
        Raises:
            ValueError: If parameters are invalid
            FileNotFoundError: If required files don't exist
        """
        self.parameters = parameters
        self.parameters.validate()
        
        if self.parameters.logger:
            self.parameters.logger.info("Initializing DPMDWaterInputGenerator")
            self.parameters.logger.info(f"DPMD model: {self.parameters.dpmd_model_path}")
            self.parameters.logger.info(f"Ensemble: {self.parameters.ensemble}")
            self.parameters.logger.info(f"Temperature: {self.parameters.temperature} K")
            if self.parameters.ensemble == "NPT":
                self.parameters.logger.info(f"Pressure: {self.parameters.pressure} atm")
    
    def generate(self) -> str:
        """
        Generate LAMMPS input file for DPMD water simulation.
        
        Returns:
            Path to generated LAMMPS input file
        """
        if self.parameters.logger:
            self.parameters.logger.info("Generating DPMD LAMMPS input file")
        
        output_path = Path(self.parameters.output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_path, 'w') as f:
            self._write_header(f)
            self._write_initialization(f)
            self._write_dpmd_potential(f)
            self._write_setup(f)
            self._write_equilibration(f)
            self._write_production(f)
        
        if self.parameters.logger:
            self.parameters.logger.success(f"DPMD LAMMPS input file generated: {output_path}")
        
        return str(output_path)
    
    def _write_header(self, f):
        """Write file header with metadata."""
        f.write(f"# LAMMPS input script for DeepMD water simulation\n")
        f.write(f"# Generated by mlip-struct-gen on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"# DPMD model: {self.parameters.dpmd_model_path.name}\n")
        f.write(f"# Ensemble: {self.parameters.ensemble}\n")
        f.write(f"# Temperature: {self.parameters.temperature} K\n")
        if self.parameters.ensemble == "NPT":
            f.write(f"# Pressure: {self.parameters.pressure} atm\n")
        f.write(f"# Timestep: {self.parameters.timestep} fs\n")
        f.write("\n")
    
    def _write_initialization(self, f):
        """Write initialization commands."""
        f.write("# Initialization\n")
        f.write("clear\n")
        f.write("units metal\n")  # DeepMD uses metal units
        f.write("atom_style full\n")  # Use full style to support bonds/angles/charges
        f.write("boundary p p p\n")
        f.write("\n")
        
        f.write("# Read data file\n")
        f.write(f"read_data {self.parameters.lammps_data_file}\n")
        f.write("\n")
        
        f.write("# Define atom types for DeepMD\n")
        f.write("# Assuming type 1 = O, type 2 = H\n")
        f.write("mass 1 15.999\n")  # Oxygen mass
        f.write("mass 2 1.008\n")   # Hydrogen mass
        f.write("\n")
    
    def _write_dpmd_potential(self, f):
        """Write DeepMD potential setup."""
        f.write("# Load DeepMD plugin\n")
        f.write("plugin load /Users/osman_mbp/Osman_Macbook_Pro/Electrolyte_Microenvironment/MLIP_Structure_Generation/mlip_struct_gen/.venv/lib/python3.11/site-packages/deepmd/lib/libdeepmd_lmpplugin.so\n")
        f.write("\n")
        
        f.write("# Define bond and angle styles (needed for full atom style)\n")
        f.write("bond_style zero\n")
        f.write("bond_coeff *\n")
        f.write("angle_style zero\n")
        f.write("angle_coeff *\n")
        f.write("\n")
        
        f.write("# Turn off special bonds since DPMD handles all interactions\n")
        f.write("special_bonds lj 0.0 0.0 0.0 coul 0.0 0.0 0.0\n")
        f.write("\n")
        
        f.write("# DeepMD potential setup\n")
        f.write(f"pair_style deepmd {self.parameters.dpmd_model_path}\n")
        f.write("pair_coeff * *\n")
        f.write("\n")
        
        f.write("# Neighbor list settings for DeepMD\n")
        f.write("neighbor 0.3 bin\n")  # Smaller skin for neural network potential
        f.write("neigh_modify every 1 delay 0 check yes\n")
        f.write("\n")
        
        # Add comm_modify if RDF is being computed
        if isinstance(self.parameters, DPMDWaterInputParameters) and self.parameters.compute_rdf:
            f.write("# Extend communication cutoff for RDF computation\n")
            f.write(f"comm_modify cutoff {self.parameters.rdf_cutoff + 2.0}\n")
            f.write("\n")
    
    def _write_setup(self, f):
        """Write simulation setup."""
        f.write("# Simulation setup\n")
        # Convert timestep from fs to ps (metal units)
        timestep_ps = self.parameters.timestep / 1000.0
        f.write(f"timestep {timestep_ps:.6f}\n")
        f.write("\n")
        
        f.write("# Generate initial velocities\n")
        f.write(f"velocity all create {self.parameters.temperature} {self.parameters.seed} dist gaussian\n")
        f.write("\n")
        
        f.write("# Output settings\n")
        f.write(f"thermo {self.parameters.thermo_frequency}\n")
        f.write("thermo_style custom step temp press pe ke etotal vol density\n")
        f.write("\n")
        
        f.write("# Compute system properties\n")
        f.write("compute myTemp all temp\n")
        f.write("compute myPE all pe\n")
        f.write("compute myKE all ke\n")
        f.write("\n")
        
        # Add water-specific analysis if requested
        if isinstance(self.parameters, DPMDWaterInputParameters):
            self._write_water_analysis_setup(f)
    
    def _write_water_analysis_setup(self, f):
        """Write water-specific analysis setup."""
        params = self.parameters
        
        if params.compute_rdf:
            f.write("# Radial distribution function\n")
            f.write(f"compute rdf_OO all rdf {params.rdf_nbins} 1 1 cutoff {params.rdf_cutoff}\n")
            f.write(f"compute rdf_OH all rdf {params.rdf_nbins} 1 2 cutoff {params.rdf_cutoff}\n")
            f.write(f"compute rdf_HH all rdf {params.rdf_nbins} 2 2 cutoff {params.rdf_cutoff}\n")
            f.write("\n")
        
        if params.compute_msd:
            f.write("# Mean squared displacement\n")
            f.write("group oxygen type 1\n")
            f.write("group hydrogen type 2\n")
            f.write(f"compute msd_O oxygen msd com yes average yes\n")
            f.write(f"compute msd_H hydrogen msd com yes average yes\n")
            f.write("\n")
        
        if params.compute_hbonds:
            f.write("# Hydrogen bond analysis\n")
            f.write("# Note: This requires custom compute or post-processing\n")
            f.write(f"# H-bond criteria: O-O < {params.hbond_cutoff} Å, O-H-O angle > {180 - params.hbond_angle}°\n")
            f.write("\n")
    
    def _write_equilibration(self, f):
        """Write equilibration phase."""
        # Convert time to steps
        timestep_ps = self.parameters.timestep / 1000.0
        equilibration_steps = int(self.parameters.equilibration_time / timestep_ps)
        
        f.write("# Equilibration phase\n")
        f.write(f"# {self.parameters.equilibration_time} ps ({equilibration_steps} steps)\n")
        f.write("\n")
        
        # Choose integrator based on ensemble
        if self.parameters.ensemble == "NVE":
            f.write("# NVE ensemble\n")
            f.write("fix nve_eq all nve\n")
        elif self.parameters.ensemble == "NVT":
            f.write("# NVT ensemble with Nosé-Hoover thermostat\n")
            # Convert damping time to metal units (ps)
            f.write(f"fix nvt_eq all nvt temp {self.parameters.temperature} {self.parameters.temperature} {self.parameters.thermostat_damping}\n")
        elif self.parameters.ensemble == "NPT":
            f.write("# NPT ensemble with Nosé-Hoover thermostat and barostat\n")
            # Convert pressure from atm to bars (metal units)
            pressure_bar = self.parameters.pressure * 1.01325
            f.write(f"fix npt_eq all npt temp {self.parameters.temperature} {self.parameters.temperature} {self.parameters.thermostat_damping} ")
            f.write(f"iso {pressure_bar} {pressure_bar} {self.parameters.barostat_damping}\n")
        
        f.write("\n")
        f.write("# Run equilibration\n")
        f.write(f"run {equilibration_steps}\n")
        f.write("\n")
        
        f.write("# Unfix equilibration integrator\n")
        if self.parameters.ensemble == "NVE":
            f.write("unfix nve_eq\n")
        elif self.parameters.ensemble == "NVT":
            f.write("unfix nvt_eq\n")
        elif self.parameters.ensemble == "NPT":
            f.write("unfix npt_eq\n")
        f.write("\n")
    
    def _write_production(self, f):
        """Write production phase."""
        # Convert time to steps
        timestep_ps = self.parameters.timestep / 1000.0
        production_steps = int(self.parameters.production_time / timestep_ps)
        
        f.write("# Production phase\n")
        f.write(f"# {self.parameters.production_time} ps ({production_steps} steps)\n")
        f.write("\n")
        
        # Reset timestep counter
        f.write("reset_timestep 0\n")
        f.write("\n")
        
        # Production run output settings
        f.write("# Production run output settings\n")
        # Convert dump_freq from ps to steps
        dump_freq_steps = int(self.parameters.dump_freq / timestep_ps)
        f.write(f"variable dump_freq equal {dump_freq_steps}\n")
        f.write("\n")
        
        f.write("# Trajectory output\n")
        f.write("dump 1 all custom ${dump_freq} trajectory.lammpstrj id type x y z vx vy vz\n")
        f.write("dump_modify 1 sort id\n")
        f.write("\n")
        
        f.write("# Additional trajectory for visualization\n")
        f.write("dump 2 all atom ${dump_freq} pos.lammpstrj\n")
        f.write("dump_modify 2 scale no\n")
        f.write("\n")
        
        # Production integrator (same as equilibration)
        if self.parameters.ensemble == "NVE":
            f.write("# NVE ensemble\n")
            f.write("fix nve_prod all nve\n")
        elif self.parameters.ensemble == "NVT":
            f.write("# NVT ensemble with Nosé-Hoover thermostat\n")
            f.write(f"fix nvt_prod all nvt temp {self.parameters.temperature} {self.parameters.temperature} {self.parameters.thermostat_damping}\n")
        elif self.parameters.ensemble == "NPT":
            f.write("# NPT ensemble with Nosé-Hoover thermostat and barostat\n")
            pressure_bar = self.parameters.pressure * 1.01325
            f.write(f"fix npt_prod all npt temp {self.parameters.temperature} {self.parameters.temperature} {self.parameters.thermostat_damping} ")
            f.write(f"iso {pressure_bar} {pressure_bar} {self.parameters.barostat_damping}\n")
        
        f.write("\n")
        
        f.write("# Average properties over production run\n")
        f.write("fix ave_props all ave/time 1 1000 1000 c_myTemp c_myPE c_myKE file properties.txt\n")
        
        # Add water-specific analysis outputs
        if isinstance(self.parameters, DPMDWaterInputParameters):
            self._write_water_analysis_output(f)
        
        f.write("\n")
        f.write("# Run production\n")
        f.write(f"run {production_steps}\n")
        f.write("\n")
        
        f.write("# Final output\n")
        f.write("write_data final_structure.data\n")
        f.write("write_restart final.restart\n")
        
        # Write final RDFs if computed
        if isinstance(self.parameters, DPMDWaterInputParameters) and self.parameters.compute_rdf:
            f.write("\n# Write final RDFs\n")
            f.write("fix rdf_OO_out all ave/time 1 1 1 c_rdf_OO[*] file rdf_OO.dat mode vector\n")
            f.write("fix rdf_OH_out all ave/time 1 1 1 c_rdf_OH[*] file rdf_OH.dat mode vector\n")
            f.write("fix rdf_HH_out all ave/time 1 1 1 c_rdf_HH[*] file rdf_HH.dat mode vector\n")
            f.write("run 0\n")
        
        f.write("\n")
        f.write('print "Simulation completed successfully"\n')
        f.write("\n")
        
        f.write("# Print final averages\n")
        f.write('print "========================================"\n')
        f.write('print "Final average temperature: $(c_myTemp)"\n')
        f.write('print "Final average potential energy: $(c_myPE)"\n')
        f.write('print "Final average kinetic energy: $(c_myKE)"\n')
        f.write('print "========================================"\n')
    
    def _write_water_analysis_output(self, f):
        """Write water-specific analysis outputs during production."""
        params = self.parameters
        
        if params.compute_msd:
            f.write("# Output MSD data\n")
            f.write(f"fix msd_out all ave/time {params.msd_sample_freq} 1 {params.msd_sample_freq} ")
            f.write("c_msd_O[4] c_msd_H[4] file msd.dat\n")
        
        if params.compute_rdf:
            f.write("# Output RDF data periodically\n")
            rdf_freq = int(self.parameters.production_time / self.parameters.timestep * 100)  # Every 1% of production
            f.write(f"fix rdf_OO_ave all ave/time 1 {rdf_freq} {rdf_freq} c_rdf_OO[*] file rdf_OO_ave.dat mode vector ave running\n")
            f.write(f"fix rdf_OH_ave all ave/time 1 {rdf_freq} {rdf_freq} c_rdf_OH[*] file rdf_OH_ave.dat mode vector ave running\n")


def create_dpmd_water_simulation(
    dpmd_model_path: Union[str, Path],
    lammps_data_file: Union[str, Path],
    output_dir: Union[str, Path] = ".",
    use_water_parameters: bool = True,
    **kwargs
) -> str:
    """
    Convenience function to create a DPMD water simulation.
    
    Args:
        dpmd_model_path: Path to the DeepMD model file
        lammps_data_file: Path to LAMMPS data file
        output_dir: Directory for output files
        use_water_parameters: If True, use DPMDWaterInputParameters
        **kwargs: Additional arguments passed to parameter class
    
    Returns:
        Path to generated LAMMPS input file
    """
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Set default output file if not provided
    if 'output_file' not in kwargs:
        kwargs['output_file'] = str(output_dir / "dpmd_water.in")
    
    # Create appropriate parameter object
    if use_water_parameters:
        parameters = DPMDWaterInputParameters(
            dpmd_model_path=dpmd_model_path,
            lammps_data_file=lammps_data_file,
            **kwargs
        )
    else:
        parameters = DPMDInputParameters(
            dpmd_model_path=dpmd_model_path,
            lammps_data_file=lammps_data_file,
            **kwargs
        )
    
    generator = DPMDWaterInputGenerator(parameters)
    return generator.generate()